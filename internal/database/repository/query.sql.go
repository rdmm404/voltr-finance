// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLlmMessage = `-- name: CreateLlmMessage :exec
INSERT INTO llm_message (session_id, role, contents) VALUES ($1, $2, $3)
`

type CreateLlmMessageParams struct {
	SessionID int32  `json:"sessionId"`
	Role      string `json:"role"`
	Contents  []byte `json:"contents"`
}

func (q *Queries) CreateLlmMessage(ctx context.Context, arg CreateLlmMessageParams) error {
	_, err := q.db.Exec(ctx, createLlmMessage, arg.SessionID, arg.Role, arg.Contents)
	return err
}

const createLlmSession = `-- name: CreateLlmSession :one
INSERT INTO llm_session (user_id) VALUES ($1) RETURNING id, user_id, created_at, updated_at
`

// ******************* LLM *******************
func (q *Queries) CreateLlmSession(ctx context.Context, userID int32) (LlmSession, error) {
	row := q.db.QueryRow(ctx, createLlmSession, userID)
	var i LlmSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transaction
(
    amount,
    is_paid,
    amount_owed,
    budget_category_id,
    description,
    transaction_date,
    transaction_id,
    transaction_type,
    paid_by,
    household_id,
    notes
)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, amount, paid_by, amount_owed, budget_category_id, description, transaction_date, transaction_id, transaction_type, notes, owed_by, household_id, is_paid, payment_date, created_at, updated_at
`

type CreateTransactionParams struct {
	Amount           float32            `json:"amount"`
	IsPaid           *bool              `json:"isPaid"`
	AmountOwed       *float32           `json:"amountOwed"`
	BudgetCategoryID *int32             `json:"budgetCategoryId"`
	Description      *string            `json:"description"`
	TransactionDate  pgtype.Timestamptz `json:"transactionDate"`
	TransactionID    *string            `json:"transactionId"`
	TransactionType  *int32             `json:"transactionType"`
	PaidBy           int32              `json:"paidBy"`
	HouseholdID      *int32             `json:"householdId"`
	Notes            *string            `json:"notes"`
}

// WRITES
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.IsPaid,
		arg.AmountOwed,
		arg.BudgetCategoryID,
		arg.Description,
		arg.TransactionDate,
		arg.TransactionID,
		arg.TransactionType,
		arg.PaidBy,
		arg.HouseholdID,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.PaidBy,
		&i.AmountOwed,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.TransactionType,
		&i.Notes,
		&i.OwedBy,
		&i.HouseholdID,
		&i.IsPaid,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDetailsByDiscordId = `-- name: GetUserDetailsByDiscordId :one

SELECT users.id, users.discord_id, users.name, users.created_at, users.updated_at, household.id, household.name, household.created_at, household.updated_at FROM users
JOIN household_user on users.id = household_user.user_id
JOIN household on household_user.household_id = household.id
WHERE users.discord_id = $1
`

type GetUserDetailsByDiscordIdRow struct {
	User      User      `json:"user"`
	Household Household `json:"household"`
}

// ******************* users *******************
// READS
func (q *Queries) GetUserDetailsByDiscordId(ctx context.Context, discordID *string) (GetUserDetailsByDiscordIdRow, error) {
	row := q.db.QueryRow(ctx, getUserDetailsByDiscordId, discordID)
	var i GetUserDetailsByDiscordIdRow
	err := row.Scan(
		&i.User.ID,
		&i.User.DiscordID,
		&i.User.Name,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Household.ID,
		&i.Household.Name,
		&i.Household.CreatedAt,
		&i.Household.UpdatedAt,
	)
	return i, err
}

const listLlmMessagesByUserId = `-- name: ListLlmMessagesByUserId :many
SELECT m.id, m.session_id, m.role, m.contents FROM llm_message m
JOIN llm_session s ON m.session_id = s.id
WHERE s.user_id = $1
`

func (q *Queries) ListLlmMessagesByUserId(ctx context.Context, userID int32) ([]LlmMessage, error) {
	rows, err := q.db.Query(ctx, listLlmMessagesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmMessage
	for rows.Next() {
		var i LlmMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByHousehold = `-- name: ListTransactionsByHousehold :many

SELECT id, amount, paid_by, amount_owed, budget_category_id, description, transaction_date, transaction_id, transaction_type, notes, owed_by, household_id, is_paid, payment_date, created_at, updated_at FROM transaction
WHERE transaction_type=2 AND household_id = $1
`

// ******************* transaction *******************
// READS
func (q *Queries) ListTransactionsByHousehold(ctx context.Context, householdID *int32) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByHousehold, householdID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaidBy,
			&i.AmountOwed,
			&i.BudgetCategoryID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionID,
			&i.TransactionType,
			&i.Notes,
			&i.OwedBy,
			&i.HouseholdID,
			&i.IsPaid,
			&i.PaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionById = `-- name: UpdateTransactionById :one
UPDATE
    transaction
SET
    amount = CASE
        WHEN $1::bool THEN $2::real
        ELSE amount
    END,
    paid_by = CASE
        WHEN $3::bool THEN $4::int
        ELSE paid_by
    END,
    budget_category_id = CASE
        WHEN $5::bool THEN $6::int
        ELSE budget_category_id
    END,
    description = CASE
        WHEN $7::bool THEN $8::text
        ELSE description
    END,
    transaction_date = CASE
        WHEN $9::bool THEN $10::timestamp
        ELSE transaction_date
    END,
    transaction_id = CASE
        WHEN $11::bool THEN $12::text
        ELSE transaction_id
    END,
    transaction_type = CASE
        WHEN $13::bool THEN $14::text
        ELSE transaction_type
    END,
    notes = CASE
        WHEN $15::bool THEN $16::text
        ELSE notes
    END,
    household_id = CASE
        WHEN $17::bool THEN $18::int
        ELSE household_id
    END,
    owed_by = CASE
        WHEN $19::bool THEN $20::int
        ELSE owed_by
    END,
    amount_owed = CASE
        WHEN $21::bool THEN $22::real
        ELSE amount_owed
    END,
    is_paid = CASE
        WHEN $23::bool THEN $24::bool
        ELSE is_paid
    END,
    payment_date = CASE
        WHEN $25::bool THEN $26::timestamp
        ELSE payment_date
    END
WHERE
    id = ANY($27::int[]) RETURNING id, amount, paid_by, amount_owed, budget_category_id, description, transaction_date, transaction_id, transaction_type, notes, owed_by, household_id, is_paid, payment_date, created_at, updated_at
`

type UpdateTransactionByIdParams struct {
	SetAmount           bool             `json:"setAmount"`
	Amount              float32          `json:"amount"`
	SetPaidBy           bool             `json:"setPaidBy"`
	PaidBy              int32            `json:"paidBy"`
	SetBudgetCategoryID bool             `json:"setBudgetCategoryId"`
	BudgetCategoryID    *int32           `json:"budgetCategoryId"`
	SetDescription      bool             `json:"setDescription"`
	Description         *string          `json:"description"`
	SetTransactionDate  bool             `json:"setTransactionDate"`
	TransactionDate     pgtype.Timestamp `json:"transactionDate"`
	SetTransactionID    bool             `json:"setTransactionId"`
	TransactionID       *string          `json:"transactionId"`
	SetTransactionType  bool             `json:"setTransactionType"`
	TransactionType     *string          `json:"transactionType"`
	SetNotes            bool             `json:"setNotes"`
	Notes               *string          `json:"notes"`
	SetHouseholdID      bool             `json:"setHouseholdId"`
	HouseholdID         *int32           `json:"householdId"`
	SetOwedBy           bool             `json:"setOwedBy"`
	OwedBy              *int32           `json:"owedBy"`
	SetAmountOwed       bool             `json:"setAmountOwed"`
	AmountOwed          *float32         `json:"amountOwed"`
	SetIsPaid           bool             `json:"setIsPaid"`
	IsPaid              *bool            `json:"isPaid"`
	SetPaymentDate      bool             `json:"setPaymentDate"`
	PaymentDate         pgtype.Timestamp `json:"paymentDate"`
	Ids                 []int32          `json:"ids"`
}

func (q *Queries) UpdateTransactionById(ctx context.Context, arg UpdateTransactionByIdParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionById,
		arg.SetAmount,
		arg.Amount,
		arg.SetPaidBy,
		arg.PaidBy,
		arg.SetBudgetCategoryID,
		arg.BudgetCategoryID,
		arg.SetDescription,
		arg.Description,
		arg.SetTransactionDate,
		arg.TransactionDate,
		arg.SetTransactionID,
		arg.TransactionID,
		arg.SetTransactionType,
		arg.TransactionType,
		arg.SetNotes,
		arg.Notes,
		arg.SetHouseholdID,
		arg.HouseholdID,
		arg.SetOwedBy,
		arg.OwedBy,
		arg.SetAmountOwed,
		arg.AmountOwed,
		arg.SetIsPaid,
		arg.IsPaid,
		arg.SetPaymentDate,
		arg.PaymentDate,
		arg.Ids,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.PaidBy,
		&i.AmountOwed,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.TransactionType,
		&i.Notes,
		&i.OwedBy,
		&i.HouseholdID,
		&i.IsPaid,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
