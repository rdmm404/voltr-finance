// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transaction
(
    amount,
    is_paid,
    amount_owed,
    budget_category_id,
    description,
    transaction_date,
    transaction_id,
    transaction_type,
    paid_by,
    household_id,
    notes
)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, amount, paid_by, amount_owed, budget_category_id, description, transaction_date, transaction_id, transaction_type, notes, owed_by, household_id, is_paid, payment_date, created_at, updated_at
`

type CreateTransactionParams struct {
	Amount           float32            `json:"amount"`
	IsPaid           *bool              `json:"isPaid"`
	AmountOwed       *float32           `json:"amountOwed"`
	BudgetCategoryID *int32             `json:"budgetCategoryId"`
	Description      *string            `json:"description"`
	TransactionDate  pgtype.Timestamptz `json:"transactionDate"`
	TransactionID    *string            `json:"transactionId"`
	TransactionType  *int32             `json:"transactionType"`
	PaidBy           int32              `json:"paidBy"`
	HouseholdID      *int32             `json:"householdId"`
	Notes            *string            `json:"notes"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.IsPaid,
		arg.AmountOwed,
		arg.BudgetCategoryID,
		arg.Description,
		arg.TransactionDate,
		arg.TransactionID,
		arg.TransactionType,
		arg.PaidBy,
		arg.HouseholdID,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.PaidBy,
		&i.AmountOwed,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.TransactionType,
		&i.Notes,
		&i.OwedBy,
		&i.HouseholdID,
		&i.IsPaid,
		&i.PaymentDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDetailsByDiscordId = `-- name: GetUserDetailsByDiscordId :one
SELECT users.id, users.discord_id, users.name, users.created_at, users.updated_at, household.id, household.name, household.created_at, household.updated_at FROM users
JOIN household_user on users.id = household_user.user_id
JOIN household on household_user.household_id = household.id
WHERE users.discord_id = $1
`

type GetUserDetailsByDiscordIdRow struct {
	User      User      `json:"user"`
	Household Household `json:"household"`
}

func (q *Queries) GetUserDetailsByDiscordId(ctx context.Context, discordID *string) (GetUserDetailsByDiscordIdRow, error) {
	row := q.db.QueryRow(ctx, getUserDetailsByDiscordId, discordID)
	var i GetUserDetailsByDiscordIdRow
	err := row.Scan(
		&i.User.ID,
		&i.User.DiscordID,
		&i.User.Name,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Household.ID,
		&i.Household.Name,
		&i.Household.CreatedAt,
		&i.Household.UpdatedAt,
	)
	return i, err
}

const listTransactionsByHousehold = `-- name: ListTransactionsByHousehold :many
SELECT id, amount, paid_by, amount_owed, budget_category_id, description, transaction_date, transaction_id, transaction_type, notes, owed_by, household_id, is_paid, payment_date, created_at, updated_at FROM transaction
WHERE transaction_type=2 AND household_id = $1
`

func (q *Queries) ListTransactionsByHousehold(ctx context.Context, householdID *int32) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByHousehold, householdID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.PaidBy,
			&i.AmountOwed,
			&i.BudgetCategoryID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionID,
			&i.TransactionType,
			&i.Notes,
			&i.OwedBy,
			&i.HouseholdID,
			&i.IsPaid,
			&i.PaymentDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
