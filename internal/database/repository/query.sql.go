// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLlmMessage = `-- name: CreateLlmMessage :one
INSERT INTO
    llm_message (session_id, user_id, role, contents, parent_id)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateLlmMessageParams struct {
	SessionID int32  `json:"sessionId"`
	UserID    int32  `json:"userId"`
	Role      string `json:"role"`
	Contents  []byte `json:"contents"`
	ParentID  *int32 `json:"parentId"`
}

// Messages
func (q *Queries) CreateLlmMessage(ctx context.Context, arg CreateLlmMessageParams) (int32, error) {
	row := q.db.QueryRow(ctx, createLlmMessage,
		arg.SessionID,
		arg.UserID,
		arg.Role,
		arg.Contents,
		arg.ParentID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createLlmSession = `-- name: CreateLlmSession :one
INSERT INTO
    llm_session (user_id, source_id)
VALUES
    ($1, $2) RETURNING id, user_id, source_id, created_at, updated_at
`

type CreateLlmSessionParams struct {
	UserID   int32  `json:"userId"`
	SourceID string `json:"sourceId"`
}

// ******************* LLM *******************
// Session
func (q *Queries) CreateLlmSession(ctx context.Context, arg CreateLlmSessionParams) (LlmSession, error) {
	row := q.db.QueryRow(ctx, createLlmSession, arg.UserID, arg.SourceID)
	var i LlmSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transaction
(
    amount,
    budget_category_id,
    description,
    transaction_date,
    transaction_id,
    author_id,
    household_id,
    notes
)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at
`

type CreateTransactionParams struct {
	Amount           float32            `json:"amount"`
	BudgetCategoryID *int32             `json:"budgetCategoryId"`
	Description      *string            `json:"description"`
	TransactionDate  pgtype.Timestamptz `json:"transactionDate"`
	TransactionID    *string            `json:"transactionId"`
	AuthorID         int32              `json:"authorId"`
	HouseholdID      *int32             `json:"householdId"`
	Notes            *string            `json:"notes"`
}

// WRITES
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.BudgetCategoryID,
		arg.Description,
		arg.TransactionDate,
		arg.TransactionID,
		arg.AuthorID,
		arg.HouseholdID,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AuthorID,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.HouseholdID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveSessionBySourceId = `-- name: GetActiveSessionBySourceId :one
SELECT
    id, user_id, source_id, created_at, updated_at
FROM
    llm_session
WHERE
    source_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetActiveSessionBySourceId(ctx context.Context, sourceID string) (LlmSession, error) {
	row := q.db.QueryRow(ctx, getActiveSessionBySourceId, sourceID)
	var i LlmSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByDiscordId = `-- name: GetUserByDiscordId :one
SELECT id, discord_id, name, created_at, updated_at FROM users WHERE discord_id = $1
`

func (q *Queries) GetUserByDiscordId(ctx context.Context, discordID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByDiscordId, discordID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDetailsByDiscordId = `-- name: GetUserDetailsByDiscordId :one

SELECT users.id, users.discord_id, users.name, users.created_at, users.updated_at, household.id, household.name, household.created_at, household.updated_at FROM users
JOIN household_user on users.id = household_user.user_id
JOIN household on household_user.household_id = household.id
WHERE users.discord_id = $1
`

type GetUserDetailsByDiscordIdRow struct {
	User      User      `json:"user"`
	Household Household `json:"household"`
}

// ******************* users *******************
// READS
func (q *Queries) GetUserDetailsByDiscordId(ctx context.Context, discordID string) (GetUserDetailsByDiscordIdRow, error) {
	row := q.db.QueryRow(ctx, getUserDetailsByDiscordId, discordID)
	var i GetUserDetailsByDiscordIdRow
	err := row.Scan(
		&i.User.ID,
		&i.User.DiscordID,
		&i.User.Name,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Household.ID,
		&i.Household.Name,
		&i.Household.CreatedAt,
		&i.Household.UpdatedAt,
	)
	return i, err
}

const listLlmMessagesBySessionId = `-- name: ListLlmMessagesBySessionId :many
SELECT
    m.id, m.session_id, m.parent_id, m.role, m.contents, m.user_id, m.created_at, m.updated_at, u.id, u.discord_id, u.name, u.created_at, u.updated_at, h.id, h.name, h.created_at, h.updated_at
FROM
    llm_message m
JOIN
    users u on u.id = m.user_id
LEFT JOIN household_user hu on hu.user_id = u.id
LEFT JOIN household h on h.id = hu.household_id
WHERE
    m.session_id = $1
ORDER BY
    m.created_at ASC
`

type ListLlmMessagesBySessionIdRow struct {
	LlmMessage LlmMessage `json:"llmMessage"`
	User       User       `json:"user"`
	Household  Household  `json:"household"`
}

func (q *Queries) ListLlmMessagesBySessionId(ctx context.Context, sessionID int32) ([]ListLlmMessagesBySessionIdRow, error) {
	rows, err := q.db.Query(ctx, listLlmMessagesBySessionId, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLlmMessagesBySessionIdRow
	for rows.Next() {
		var i ListLlmMessagesBySessionIdRow
		if err := rows.Scan(
			&i.LlmMessage.ID,
			&i.LlmMessage.SessionID,
			&i.LlmMessage.ParentID,
			&i.LlmMessage.Role,
			&i.LlmMessage.Contents,
			&i.LlmMessage.UserID,
			&i.LlmMessage.CreatedAt,
			&i.LlmMessage.UpdatedAt,
			&i.User.ID,
			&i.User.DiscordID,
			&i.User.Name,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.Household.ID,
			&i.Household.Name,
			&i.Household.CreatedAt,
			&i.Household.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByHousehold = `-- name: ListTransactionsByHousehold :many

SELECT id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at FROM transaction
WHERE transaction_type=2 AND household_id = $1
`

// ******************* transaction *******************
// READS
func (q *Queries) ListTransactionsByHousehold(ctx context.Context, householdID *int32) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByHousehold, householdID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.AuthorID,
			&i.BudgetCategoryID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionID,
			&i.HouseholdID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionById = `-- name: UpdateTransactionById :one
UPDATE
    transaction
SET
    amount = CASE
        WHEN $1::bool THEN $2::real
        ELSE amount
    END,
    author_id = CASE
        WHEN $3::bool THEN $4::int
        ELSE author_id
    END,
    budget_category_id = CASE
        WHEN $5::bool THEN $6::int
        ELSE budget_category_id
    END,
    description = CASE
        WHEN $7::bool THEN $8::text
        ELSE description
    END,
    transaction_date = CASE
        WHEN $9::bool THEN $10::timestamp
        ELSE transaction_date
    END,
    transaction_id = CASE
        WHEN $11::bool THEN $12::text
        ELSE transaction_id
    END,
    notes = CASE
        WHEN $13::bool THEN $14::text
        ELSE notes
    END,
    household_id = CASE
        WHEN $15::bool THEN $16::int
        ELSE household_id
    END
WHERE
    id = ANY($17::int[]) RETURNING id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at
`

type UpdateTransactionByIdParams struct {
	SetAmount           bool             `json:"setAmount"`
	Amount              float32          `json:"amount"`
	SetAuthorID         bool             `json:"setAuthorId"`
	AuthorID            int32            `json:"authorId"`
	SetBudgetCategoryID bool             `json:"setBudgetCategoryId"`
	BudgetCategoryID    *int32           `json:"budgetCategoryId"`
	SetDescription      bool             `json:"setDescription"`
	Description         *string          `json:"description"`
	SetTransactionDate  bool             `json:"setTransactionDate"`
	TransactionDate     pgtype.Timestamp `json:"transactionDate"`
	SetTransactionID    bool             `json:"setTransactionId"`
	TransactionID       *string          `json:"transactionId"`
	SetNotes            bool             `json:"setNotes"`
	Notes               *string          `json:"notes"`
	SetHouseholdID      bool             `json:"setHouseholdId"`
	HouseholdID         *int32           `json:"householdId"`
	Ids                 []int32          `json:"ids"`
}

func (q *Queries) UpdateTransactionById(ctx context.Context, arg UpdateTransactionByIdParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionById,
		arg.SetAmount,
		arg.Amount,
		arg.SetAuthorID,
		arg.AuthorID,
		arg.SetBudgetCategoryID,
		arg.BudgetCategoryID,
		arg.SetDescription,
		arg.Description,
		arg.SetTransactionDate,
		arg.TransactionDate,
		arg.SetTransactionID,
		arg.TransactionID,
		arg.SetNotes,
		arg.Notes,
		arg.SetHouseholdID,
		arg.HouseholdID,
		arg.Ids,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AuthorID,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.HouseholdID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
