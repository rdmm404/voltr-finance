// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLlmMessage = `-- name: CreateLlmMessage :one
INSERT INTO
    llm_message (session_id, user_id, role, contents, parent_id)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateLlmMessageParams struct {
	SessionID int64  `json:"sessionId"`
	UserID    int64  `json:"userId"`
	Role      string `json:"role"`
	Contents  []byte `json:"contents"`
	ParentID  *int64 `json:"parentId"`
}

// Messages
func (q *Queries) CreateLlmMessage(ctx context.Context, arg CreateLlmMessageParams) (int64, error) {
	row := q.db.QueryRow(ctx, createLlmMessage,
		arg.SessionID,
		arg.UserID,
		arg.Role,
		arg.Contents,
		arg.ParentID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createLlmSession = `-- name: CreateLlmSession :one
INSERT INTO
    llm_session (user_id, source_id)
VALUES
    ($1, $2) RETURNING id, user_id, source_id, created_at, updated_at
`

type CreateLlmSessionParams struct {
	UserID   int64  `json:"userId"`
	SourceID string `json:"sourceId"`
}

// ******************* LLM *******************
// Session
func (q *Queries) CreateLlmSession(ctx context.Context, arg CreateLlmSessionParams) (LlmSession, error) {
	row := q.db.QueryRow(ctx, createLlmSession, arg.UserID, arg.SourceID)
	var i LlmSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one

INSERT INTO transaction
(
    amount,
    budget_category_id,
    description,
    transaction_date,
    transaction_id,
    author_id,
    household_id,
    notes
)
VALUES
($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at
`

type CreateTransactionParams struct {
	Amount           float32            `json:"amount"`
	BudgetCategoryID *int64             `json:"budgetCategoryId"`
	Description      *string            `json:"description"`
	TransactionDate  pgtype.Timestamptz `json:"transactionDate"`
	TransactionID    string             `json:"transactionId"`
	AuthorID         int64              `json:"authorId"`
	HouseholdID      *int64             `json:"householdId"`
	Notes            *string            `json:"notes"`
}

// WRITES
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Amount,
		arg.BudgetCategoryID,
		arg.Description,
		arg.TransactionDate,
		arg.TransactionID,
		arg.AuthorID,
		arg.HouseholdID,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AuthorID,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.HouseholdID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveSessionBySourceId = `-- name: GetActiveSessionBySourceId :one
SELECT
    id, user_id, source_id, created_at, updated_at
FROM
    llm_session
WHERE
    source_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetActiveSessionBySourceId(ctx context.Context, sourceID string) (LlmSession, error) {
	row := q.db.QueryRow(ctx, getActiveSessionBySourceId, sourceID)
	var i LlmSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHouseholdByGuildId = `-- name: GetHouseholdByGuildId :one
SELECT id, name, guild_id, created_at, updated_at from household where guild_id = $1
`

func (q *Queries) GetHouseholdByGuildId(ctx context.Context, guildID string) (Household, error) {
	row := q.db.QueryRow(ctx, getHouseholdByGuildId, guildID)
	var i Household
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.GuildID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHouseholdUsers = `-- name: GetHouseholdUsers :many
SELECT u.id, u.discord_id, u.name, u.created_at, u.updated_at FROM users u
JOIN household_user hu on hu.user_id = u.id
WHERE hu.household_id = $1
`

func (q *Queries) GetHouseholdUsers(ctx context.Context, householdID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getHouseholdUsers, householdID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.DiscordID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdByTransactionId = `-- name: GetIdByTransactionId :one
SELECT id FROM transaction
WHERE transaction_id = $1
`

func (q *Queries) GetIdByTransactionId(ctx context.Context, transactionID string) (int64, error) {
	row := q.db.QueryRow(ctx, getIdByTransactionId, transactionID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTableAndColumnMetadata = `-- name: GetTableAndColumnMetadata :many

SELECT
  t.table_schema::text AS schema_name,
  t.table_name::text AS table_name,
  COALESCE(obj_description(pgc.oid, 'pg_class'), '')::text AS table_description,
  c.column_name::text AS column_name,
  c.data_type::text AS data_type,
  COALESCE(col_description(pgc.oid, c.ordinal_position), '')::text AS column_description,
  (c.is_nullable = 'YES')::boolean AS is_nullable,
  -- Check if part of any index
  EXISTS (
    SELECT 1
    FROM pg_catalog.pg_index i
    WHERE i.indrelid = pgc.oid
      AND c.ordinal_position = ANY(i.indkey)
  )::boolean AS is_indexed,
  -- Check if part of a unique index
  EXISTS (
    SELECT 1
    FROM pg_catalog.pg_index i
    WHERE i.indrelid = pgc.oid
      AND i.indisunique = true
      AND c.ordinal_position = ANY(i.indkey)
  )::boolean AS is_unique,
  -- 1. Foreign Key in format table.column
  COALESCE(
    (
      SELECT ta.relname || '.' || fa.attname
      FROM pg_catalog.pg_constraint con
      JOIN pg_catalog.pg_class ta ON con.confrelid = ta.oid
      JOIN pg_catalog.pg_attribute fa ON fa.attrelid = con.confrelid AND fa.attnum = ANY(con.confkey)
      WHERE con.conrelid = pgc.oid
        AND con.contype = 'f'
        AND c.ordinal_position = ANY(con.conkey)
      LIMIT 1
    ),
    ''
  )::text AS foreign_key_target,
  -- 3. Primary Key Identity
  EXISTS (
    SELECT 1
    FROM pg_catalog.pg_constraint con
    WHERE con.conrelid = pgc.oid
      AND con.contype = 'p'
      AND c.ordinal_position = ANY(con.conkey)
  )::boolean AS is_primary_key
FROM
  information_schema.tables t
  JOIN pg_catalog.pg_class pgc ON t.table_name = pgc.relname
  JOIN pg_catalog.pg_namespace pgn ON pgc.relnamespace = pgn.oid
  AND t.table_schema = pgn.nspname
  JOIN information_schema.columns c ON t.table_name = c.table_name
  AND t.table_schema = c.table_schema
WHERE
  t.table_schema = 'transactions'
  AND t.table_name = ANY($1::TEXT[])
ORDER BY
  t.table_name,
  c.ordinal_position
`

type GetTableAndColumnMetadataRow struct {
	SchemaName        string `json:"schemaName"`
	TableName         string `json:"tableName"`
	TableDescription  string `json:"tableDescription"`
	ColumnName        string `json:"columnName"`
	DataType          string `json:"dataType"`
	ColumnDescription string `json:"columnDescription"`
	IsNullable        bool   `json:"isNullable"`
	IsIndexed         bool   `json:"isIndexed"`
	IsUnique          bool   `json:"isUnique"`
	ForeignKeyTarget  string `json:"foreignKeyTarget"`
	IsPrimaryKey      bool   `json:"isPrimaryKey"`
}

// ******************* sql metadata *******************
func (q *Queries) GetTableAndColumnMetadata(ctx context.Context, tableNames []string) ([]GetTableAndColumnMetadataRow, error) {
	rows, err := q.db.Query(ctx, getTableAndColumnMetadata, tableNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTableAndColumnMetadataRow
	for rows.Next() {
		var i GetTableAndColumnMetadataRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.TableDescription,
			&i.ColumnName,
			&i.DataType,
			&i.ColumnDescription,
			&i.IsNullable,
			&i.IsIndexed,
			&i.IsUnique,
			&i.ForeignKeyTarget,
			&i.IsPrimaryKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionById = `-- name: GetTransactionById :one

SELECT id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at FROM transaction
WHERE id = $1
`

// ******************* transaction *******************
// READS
func (q *Queries) GetTransactionById(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionById, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AuthorID,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.HouseholdID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsById = `-- name: GetTransactionsById :many
SELECT id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at FROM transaction
WHERE id = ANY($1::BIGINT[])
`

func (q *Queries) GetTransactionsById(ctx context.Context, ids []int64) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsById, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.AuthorID,
			&i.BudgetCategoryID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionID,
			&i.HouseholdID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByDiscordAndHouseholdId = `-- name: GetUserByDiscordAndHouseholdId :one
SELECT u.id, u.discord_id, u.name, u.created_at, u.updated_at FROM users u
JOIN household_user hu on hu.user_id = u.id
WHERE discord_id = $1 and hu.household_id = $2
`

type GetUserByDiscordAndHouseholdIdParams struct {
	DiscordID   string `json:"discordId"`
	HouseholdID int64  `json:"householdId"`
}

func (q *Queries) GetUserByDiscordAndHouseholdId(ctx context.Context, arg GetUserByDiscordAndHouseholdIdParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByDiscordAndHouseholdId, arg.DiscordID, arg.HouseholdID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByDiscordId = `-- name: GetUserByDiscordId :one
SELECT id, discord_id, name, created_at, updated_at FROM users WHERE discord_id = $1
`

func (q *Queries) GetUserByDiscordId(ctx context.Context, discordID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByDiscordId, discordID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDetailsByDiscordId = `-- name: GetUserDetailsByDiscordId :one

SELECT users.id, users.discord_id, users.name, users.created_at, users.updated_at, household.id, household.name, household.guild_id, household.created_at, household.updated_at FROM users
JOIN household_user on users.id = household_user.user_id
JOIN household on household_user.household_id = household.id
WHERE users.discord_id = $1
`

type GetUserDetailsByDiscordIdRow struct {
	User      User      `json:"user"`
	Household Household `json:"household"`
}

// ******************* users *******************
// READS
func (q *Queries) GetUserDetailsByDiscordId(ctx context.Context, discordID string) (GetUserDetailsByDiscordIdRow, error) {
	row := q.db.QueryRow(ctx, getUserDetailsByDiscordId, discordID)
	var i GetUserDetailsByDiscordIdRow
	err := row.Scan(
		&i.User.ID,
		&i.User.DiscordID,
		&i.User.Name,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.Household.ID,
		&i.Household.Name,
		&i.Household.GuildID,
		&i.Household.CreatedAt,
		&i.Household.UpdatedAt,
	)
	return i, err
}

const listLlmMessagesBySessionId = `-- name: ListLlmMessagesBySessionId :many
SELECT
    m.id, m.session_id, m.parent_id, m.role, m.contents, m.user_id, m.created_at, m.updated_at, u.id, u.discord_id, u.name, u.created_at, u.updated_at
FROM
    llm_message m
JOIN
    users u on u.id = m.user_id
WHERE
    m.session_id = $1
ORDER BY
    m.created_at ASC
`

type ListLlmMessagesBySessionIdRow struct {
	LlmMessage LlmMessage `json:"llmMessage"`
	User       User       `json:"user"`
}

func (q *Queries) ListLlmMessagesBySessionId(ctx context.Context, sessionID int64) ([]ListLlmMessagesBySessionIdRow, error) {
	rows, err := q.db.Query(ctx, listLlmMessagesBySessionId, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLlmMessagesBySessionIdRow
	for rows.Next() {
		var i ListLlmMessagesBySessionIdRow
		if err := rows.Scan(
			&i.LlmMessage.ID,
			&i.LlmMessage.SessionID,
			&i.LlmMessage.ParentID,
			&i.LlmMessage.Role,
			&i.LlmMessage.Contents,
			&i.LlmMessage.UserID,
			&i.LlmMessage.CreatedAt,
			&i.LlmMessage.UpdatedAt,
			&i.User.ID,
			&i.User.DiscordID,
			&i.User.Name,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByHousehold = `-- name: ListTransactionsByHousehold :many
SELECT id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at FROM transaction
WHERE transaction_type=2 AND household_id = $1
`

func (q *Queries) ListTransactionsByHousehold(ctx context.Context, householdID *int64) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByHousehold, householdID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.AuthorID,
			&i.BudgetCategoryID,
			&i.Description,
			&i.TransactionDate,
			&i.TransactionID,
			&i.HouseholdID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageContents = `-- name: UpdateMessageContents :exec
UPDATE llm_message SET contents = $2 WHERE id = $1
`

type UpdateMessageContentsParams struct {
	ID       int64  `json:"id"`
	Contents []byte `json:"contents"`
}

func (q *Queries) UpdateMessageContents(ctx context.Context, arg UpdateMessageContentsParams) error {
	_, err := q.db.Exec(ctx, updateMessageContents, arg.ID, arg.Contents)
	return err
}

const updateTransactionById = `-- name: UpdateTransactionById :one
UPDATE
    transaction
SET
    amount = CASE
        WHEN $3::bool THEN $4::real
        ELSE amount
    END,
    author_id = CASE
        WHEN $5::bool THEN $6::BIGINT
        ELSE author_id
    END,
    budget_category_id = CASE
        WHEN $7::bool THEN $8::BIGINT
        ELSE budget_category_id
    END,
    description = CASE
        WHEN $9::bool THEN $10::text
        ELSE description
    END,
    transaction_date = CASE
        WHEN $11::bool THEN $12::timestamp
        ELSE transaction_date
    END,
    notes = CASE
        WHEN $13::bool THEN $14::text
        ELSE notes
    END,
    household_id = CASE
        WHEN $15::bool THEN $16::BIGINT
        ELSE household_id
    END,
    transaction_id = $2
WHERE
    id = $1 RETURNING id, amount, author_id, budget_category_id, description, transaction_date, transaction_id, household_id, notes, created_at, updated_at
`

type UpdateTransactionByIdParams struct {
	ID                  int64            `json:"id"`
	TransactionID       string           `json:"transactionId"`
	SetAmount           bool             `json:"setAmount"`
	Amount              float32          `json:"amount"`
	SetAuthorID         bool             `json:"setAuthorId"`
	AuthorID            int64            `json:"authorId"`
	SetBudgetCategoryID bool             `json:"setBudgetCategoryId"`
	BudgetCategoryID    *int64           `json:"budgetCategoryId"`
	SetDescription      bool             `json:"setDescription"`
	Description         *string          `json:"description"`
	SetTransactionDate  bool             `json:"setTransactionDate"`
	TransactionDate     pgtype.Timestamp `json:"transactionDate"`
	SetNotes            bool             `json:"setNotes"`
	Notes               *string          `json:"notes"`
	SetHouseholdID      bool             `json:"setHouseholdId"`
	HouseholdID         *int64           `json:"householdId"`
}

func (q *Queries) UpdateTransactionById(ctx context.Context, arg UpdateTransactionByIdParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionById,
		arg.ID,
		arg.TransactionID,
		arg.SetAmount,
		arg.Amount,
		arg.SetAuthorID,
		arg.AuthorID,
		arg.SetBudgetCategoryID,
		arg.BudgetCategoryID,
		arg.SetDescription,
		arg.Description,
		arg.SetTransactionDate,
		arg.TransactionDate,
		arg.SetNotes,
		arg.Notes,
		arg.SetHouseholdID,
		arg.HouseholdID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.AuthorID,
		&i.BudgetCategoryID,
		&i.Description,
		&i.TransactionDate,
		&i.TransactionID,
		&i.HouseholdID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
